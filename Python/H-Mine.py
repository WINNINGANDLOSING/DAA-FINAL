class HMine:

    def __init__(self, horizontal_database: list[set[int]], minsup_percentage: float) -> None:
        self.database = horizontal_database
        self.transactionCount = len(self.database)  #Total Transaction Count in the Input dataset

        self.minsup = int(minsup_percentage * len(self.database))
        self.out_frequents_items = [] # Frequent Items generated by H-Mine are appended one by one to this list
        self.itemsetBuffer = [None] * 200 # This buffer variable is used to store the Items under recursion to generate the final frequent-itemset
        self.mapItemToSupport = {}   #This Dictionary will be used to store the support values of all the unique items in input dataset
        self.mapItemRow = {} #This Dict will help us build the H-Struct table.
        self.rowlist = [] #This acts as a Header table storing the list of row objects

        # This is used to find the frequent-item cell of the database.
        # All the other frequent-itemsets will be found using this cell.
        self.cell = [] #This variable stores all the frequent projections in all the transactions seperated by -1

    # store the itemsets objects
    class Itemset:
        def __init__(self, item):
            self.item = item
            self.support = 0
            self.pointer = []

     # This function is used to generate frequent items using values in itemsetBuffer and prefixlen and apped that value to output list out_frequents_items
    def print(self, prefix, prefixlen, item):
        freq = []
        for val in range(prefixlen):
            freq.append(prefix[val])
        freq.append(item)

        out_str = ""
        for val in freq:
            out_str += val + ","

        temp = {out_str[:-1]}
        self.out_frequents_items.append(temp)

    #Building mapItemToSupport Dictionary with Unique Items in input dataset and it's support value
    def build_mapItemToSupport(self):
        for tran in self.database:
            for item in tran:
                if item not in self.mapItemToSupport.keys(): 
                    self.mapItemToSupport[item] = 1
                else : 
                    self.mapItemToSupport[item] += 1

    def build_mapItemRow(self):
        for keys in self.mapItemToSupport.keys():
            if self.mapItemToSupport[keys] >= self.minsup:
                rowItem = self.Itemset(keys);
                rowItem.support = self.mapItemToSupport[keys]
                self.rowlist.append(rowItem)
                self.mapItemRow[keys] = rowItem

    def build_cell_complete_mapItemRow(self):
        flist = sorted(self.mapItemRow.keys()) # f-list of frequent itemsets in sorted order

        idx = 0
        #This loop is used to append frequent projections in Cell list and append their respective pointers in mapItemRow dictionary 
        for tran in self.database:
            temp=[]
            for item in tran:
                if item in flist:
                    if item not in temp: # checking double occurences in the list
                        temp.append(item)

            if temp:
                temp = sorted(temp, key = lambda x: self.mapItemToSupport[x])
                for x in temp:
                    self.cell.append(x)
                    self.mapItemRow[x].pointer.append(idx)
                    idx += 1
                self.cell.append(-1)
                idx += 1


    # This function impletements this logic for H-mine algorithm and is called recursively 
    def hmine_recur(self, prefix=[], prefixlen=0, rowlist=[]):

        for row in rowlist:
            newRowlist=[]
            self.mapItemRow.clear()

            #traversing all pointers of row object in row list and building new recursive sub-level header
            for pointer in row.pointer:
                pointer+=1

                if self.cell[pointer]==-1:
                    continue;

                #Generating the row objects and incresing the support for all the unique items in row objects    
                while self.cell[pointer] != -1 :
                    item=self.cell[pointer]
                    if self.mapItemRow.get(item,None) == None :
                        rowItem = self.Itemset(item)
                        rowItem.support = 1
                        rowItem.pointer.append(pointer)
                        self.mapItemRow[item] = rowItem

                    else:    
                        self.mapItemRow[item].support += 1
                        self.mapItemRow[item].pointer.append(pointer)

                    pointer += 1

            #Appending only those row objects which have support greater than min_support
            for entry in self.mapItemRow:
                currentRow = self.mapItemRow[entry]
                if currentRow.support >= self.minsup:
                    newRowlist.append(currentRow)

            #Calling print function to generate the frequent items and store in output list
            self.print(self.itemsetBuffer, prefixlen, row.item)

            #Sorting newRowlist in lexical order
            if len(newRowlist) != 0 :
                newRowlist = sorted(newRowlist, key = lambda x : x.support)


                #Store current row item in buffer before recursion so that it can be used to build the frequent itemset values    
                self.itemsetBuffer[prefixlen] = row.item

                self.hmine_recur(prefix, prefixlen+1, newRowlist)
    
    def run(self):
        self.build_mapItemToSupport()
        self.build_mapItemRow()
        self.build_cell_complete_mapItemRow()
        self.hmine_recur(self.itemsetBuffer, 0, self.rowlist)
        for ans in sorted(self.out_frequents_items):
            yield ans

# TESTING
def main():
    horizontal_database =  [['1', '3', '4'], 
                            ['2', '3', '5'], 
                            ['1', '2', '3', '5'], 
                            ['2', '5'], 
                            ['1', '2', '3', '5']]      
    hmine = HMine(horizontal_database, 40/100)
    print(hmine.minsup)
    print(list(hmine.run()))

if __name__=="__main__":
    main()